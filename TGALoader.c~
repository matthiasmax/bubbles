/*
 * Nehe Lesson 33 Code (ported to Linux//GLX by Patrick Schubert 2003
 * with help from the lesson 1 basecode for Linux/GLX by Mihael Vrbanec)
 */

#include "Tga.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

BOOL LoadTGA(Texture * texture,const char * filename)				/* Load a TGA file */
{
	FILE * fTGA;													/* File pointer to texture file */
	fTGA = fopen(filename, "rb");									/* Open file for reading */

	if(fTGA == NULL)												/* If it didn't open.... */
	{
		printf("Error could not open texture file");				/* Display an error message */
		return False;												/* Exit function */
	}

	if(fread(&tgaheader, sizeof(TGAHeader), 1, fTGA) == 0)			/* Attempt to read 12 byte header from file */
	{
		printf("Error could not read file header");					/* If it fails, display an error message */
		if(fTGA != NULL)												/* Check to seeiffile is still open */
		{
			fclose(fTGA);												/* If it is, close it */
		}
		return False;													/* Exit function */
	}

	if(memcmp(uTGAcompare, &tgaheader, sizeof(tgaheader)) == 0)	/* See if header matches the predefined header of */
	{																/* an Uncompressed TGA image */
		LoadUncompressedTGA(texture, filename, fTGA);					/* If so, jump to Uncompressed TGA loading code */
	}
	else																/* If header matches neither type */
	{
		printf("Error TGA file be type 2 or type 10 ");				/* Display an error */
		fclose(fTGA);
		return False;												/* Exit function */
	}
	return True;														/* All went well, continue on */
}

BOOL LoadUncompressedTGA(Texture * texture, const char * filename, FILE * fTGA)	/* Load an uncompressed TGA (note, much of this code is based on NeHe's */
{
	GLuint cswap;															/* TGA Loading code nehe.gamedev.net) */
	if(fread(tga.header, sizeof(tga.header), 1, fTGA) == 0)				/* Read TGA header */
	{
		printf("Error could not read info header");							/* Display error */
		if(fTGA != NULL)													/* if file is still open */
		{
			fclose(fTGA);													/* Close it */
		}
		return False;														/* Return failular */
	}

	texture->width  = tga.header[1] * 256 + tga.header[0];					/* Determine The TGA Width	(highbyte*256+lowbyte) */
	texture->height = tga.header[3] * 256 + tga.header[2];					/* Determine The TGA Height	(highbyte*256+lowbyte) */
	texture->bpp	= tga.header[4];										/* Determine the bits per pixel */
	tga.Width		= texture->width;										/* Copy width into local structure */
	tga.Height		= texture->height;										/* Copy height into local structure */
	tga.Bpp			= texture->bpp;											/* Copy BPP into local structure */

	if((texture->width <= 0) || (texture->height <= 0) || ((texture->bpp != 24) && (texture->bpp !=32)))	/* Make sure all information is valid */
	{
		printf("Error invalid texture information");						/* Display Error */
		if(fTGA != NULL)													/* Check if file is still open */
		{
			fclose(fTGA);													/* If so, close it */
		}
		return False;														/* Return failed */
	}

	if(texture->bpp == 24)													/* If the BPP of the image is 24... */
	{
		texture->type	= GL_RGB;											/* Set Image type to GL_RGB */
	}
	else																	/* Else if its 32 BPP */
	{
		texture->type	= GL_RGBA;											/* Set image type to GL_RGBA */
	}

	tga.bytesPerPixel	= (tga.Bpp / 8);									/* Compute the number of BYTES per pixel */
	tga.imageSize		= (tga.bytesPerPixel * tga.Width * tga.Height);		/* Compute the total amout ofmemory needed to store data */
	texture->imageData	= malloc(tga.imageSize);							/* Allocate that much memory */

	if(texture->imageData == NULL)											/* If no space was allocated */
	{
		printf("Error could not allocate memory for image");				/* Display Error */
		fclose(fTGA);														/* Close the file */
		return False;														/* Return failed */
	}

	if(fread(texture->imageData, 1, tga.imageSize, fTGA) != tga.imageSize)	/* Attempt to read image data */
	{
		printf("Error could not read image data");							/* Display Error */
		if(texture->imageData != NULL)										/* If imagedata has data in it */
		{
			free(texture->imageData);										/* Delete data from memory */
		}
		fclose(fTGA);														/* Close file */
		return False;														/* Return failed */
	}

	/* Byte Swapping Optimized By Steve Thomas */
	for(cswap = 0; cswap < (int)tga.imageSize; cswap += tga.bytesPerPixel)
	{
		texture->imageData[cswap] ^= texture->imageData[cswap+2] ^=
		texture->imageData[cswap] ^= texture->imageData[cswap+2];
	}

	fclose(fTGA);															/* Close file */
	return True;															/* Return success */
}

